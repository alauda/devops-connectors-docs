# DevOps Connectors Approvals & Checks 产品提案

## Executive Summary

为 DevOps Connectors 引入审批与检查（Approvals & Checks）功能，在不改变 Connector 现有使用模式的前提下，为生产环境的敏感操作增加可控的审批和检查门禁。

**核心需求来源**

> "对连接到生产环境的 harbor/oci connector，配置人工审批，确保经过审核后，才进行晋级到该生产环境的 Harbor"

---

## 1. 背景与动机

### 1.1 为什么需要审批功能

当前 Connectors 平台提供了便捷的 Secretless 访问能力，用户可以通过 CSI Driver 挂载、API 调用或 Proxy 代理等方式访问工具资源。然而，对于生产环境的关键操作，仅依赖 RBAC 权限控制是不够的。

**存在的风险**

| 风险类别     | 具体风险                                               |
| ------------ | ------------------------------------------------------ |
| 未授权变更   | 具有 Connector 访问权限的用户，可随时操作生产环境的资源 |
| 操作不可追溯 | 缺乏审批记录，无法追溯变更决策                         |
| 时间窗口失控 | 变更可能在业务高峰期执行                               |

### 1.2 典型使用场景

| 场景                     | 描述                                                                              |
| ------------------------ | --------------------------------------------------------------------------------- |
| **生产环境制品晋级**     | 对连接到生产环境的 Harbor/OCI Connector，配置人工审批，确保经过审核后才进行晋级 |
| **生产集群部署审批**     | 对连接到生产集群的 K8s Connector，配置环境管理员审批                      |
| **业务时间窗口控制**     | 配置业务时间窗，确保变更仅在允许的时间窗口内执行（如 00:00-06:00）                |
| **外部系统集成（扩展）** | 与 JIRA 等外部系统集成，只有变更单完成后才允许使用 Connector                      |

---

## 2. 核心问题定义

在设计审批功能之前，需要先明确几个核心问题：

### 问题 1：审批请求的发起时机

Connector 请求是基于 HTTP 的短连接（如使用 Connector 请求工具的原始 API），审批请求**应当是预先发起的**，而不能是请求 Connector 过程中实时发起的。

### 问题 2：审批的复用范围

同一个 Pod 内使用某个 Connector 时，应该只需要审批一次，不应该每次请求都发起审批。应该是基于"某批次使用"的审批，在"这批次使用"内，一旦审批通过，后续均可正常请求。

### 问题 3：UI 场景的特殊性

用户在产品页面选择 Connector 时，前端会调用 Connector API 展示工具数据（如仓库列表、分支列表）。这与 Pipeline 或 CLI 的使用场景不同：

- UI 期望即时响应，不能等待审批流程
- 大多数 UI 操作是只读的（GET 请求）

---

## 3. 方案概述

整体流程如下：

1. **配置阶段**：Connector 配置 Approvals & Checks 规则
2. **请求阶段**：消费者（K8s CSI Driver / CLI）使用 Connector 时主动/被动发起审批请求，携带本次审批信息
3. **处理阶段**：服务端处理审批请求，对当前的 Approvals & Checks 进行评估或进入审批流程，等待结果
4. **使用阶段**：客户端发起对 Connector 的使用请求
5. **校验阶段**：服务端（API & Proxy）检查当前请求对应的审批/检查结果，若通过则允许使用，否则拒绝

---

## 4. 关键设计问题

### 4.1 审批目标（审批通过后批准的是什么）

**核心问题**：审批通过后，批准的是什么？这决定了审批结果是如何被复用的。

**示例**：开发者张三在流水线中使用生产环境的 Harbor Connector 推送镜像，审批通过后：

| 方案             | 批准的是什么               | 何时需要再次审批 | 典型场景                       |
| ---------------- | -------------------------- | ---------------- | ------------------------------ |
| **按用户**       | 批准"张三"使用该 Connector | 其他用户使用时   | 临时授权某人访问生产环境       |
| **按有效期**     | 批准"在未来 N 小时内"使用  | 有效期过后       | CLI 脚本定时执行、临时访问窗口 |
| **按 Token**     | 批准"这个 Token"使用       | Token 刷新后     | 需要严格限定单次会话           |
| **按执行上下文** | 批准"这次流水线运行"使用   | 流水线重新运行时 | 生产部署需要逐次审批           |

**方案分析**：

| 方案         | 优势                                 | 劣势                                       | 安全风险       |
| ------------ | ------------------------------------ | ------------------------------------------ | -------------- |
| 按用户       | —                                    | 退化为 RBAC，一次授权一直可用             | 中             |
| 按有效期     | 简单，易于实现                       | 无法感知上下文变化                         | 中             |
| 按 Token     | 限定更严格                           | Token 刷新导致需要频繁审批，用户较难感知 | 低             |
| 按执行上下文 | 上下文切换时需要再次审批，用户易理解 | 需要避免用户伪造                           | 中（需防伪造） |

**建议**：

- **Pipeline 场景** → 按执行上下文（PipelineRun/TaskRun/Pod）的生命周期，符合"每次部署需要确认"的用户预期，用户再次执行流水线时需要重新审批
  - PipelineRun 级别：当前 PipelineRun 生命周期内审批一次，PipelineRun 内其他 Task 使用不需要再次审批
  - TaskRun 级别：当前 TaskRun 生命周期内审批一次，TaskRun 发生重试时需要再次审批
  - Pod 级别：当前 TaskRun 创建的 Pod 生命周期内审批一次，TaskRun 发生重试时需要再次审批

- **Pod 场景** → 创建 Pod（Job、Deployment）挂载 Connector 场景，按 Pod/Owner 生命周期，Pod 重建时需重新审批
  - Pod 级别：同一个 Pod 生命周期内审批一次，Pod 重建需重新审批
  - Owner 级别：同一个 Owner（Job、Deployment）生命周期内审批一次，Pod 重建不需重新审批

- **CLI 场景** → 按 Token + 授权有效期，避免频繁审批影响使用体验。同一个 Token 的有效授权时间内审批一次，审批通过后在授权时间内可多次调用

**审批数据模型**

```
Approval = {
  Connector,
  Subject,         // User or ServiceAccount
  Context (Owner), // Optional: Pod / PipelineRun / TaskRun
  Token,           // Optional
  ValidityPeriod,  // Optional
  RequestTime,
}

ApprovalResult = {
  Status,    // Approved / Rejected
  Approver,
  Timestamp,
  Comments,
}
```

### 4.2 审批范围（哪些操作需要审批）

如果 Connector 配置了整体需要审批，会导致 UI 请求 Connector API 时被拒绝。但某些只读操作是可信任的，需要审批的场景可能仅是写入等个别场景。

**方案对比**

| 方案                           | 说明                                  | 优势                     | 劣势                              |
| ------------------------------ | ------------------------------------- | ------------------------ | --------------------------------- |
| **方案 A：Connector 整体**     | Connector 所有操作统一需要/不需要审批 | 最简单                   | 无法区分读写操作，UI 体验较差 |
| **方案 B：按 HTTP 方法**       | 按 GET/POST/PUT/DELETE 区分           | 覆盖大多数场景，配置简单 | 部分工具 HTTP 方法可能混用        |
| **方案 C：HTTP 方法 + API 路径** | 按具体 HTTP 方法 + API 路径配置       | 最精细                   | 配置复杂，维护成本高              |

**方案 A 流程**

1. CSI Driver 挂载时：
   - CSI Driver 根据 Connector 配置决定是否自动发起审批申请
   - Connector 侧完成审批动作
   - CSI Driver 根据审批结果决定是否允许挂载，并签发 Token
   - Pod 内所有请求均可正常使用该 Connector

2. UI 调用 Connectors API 时：
   - 调用需要审批的 Connector 时，API 调用将会失败
   - 或下拉框中移除需要审批的 Connector

**方案 B 流程**

1. CSI Driver 挂载时，用户按需决定是否需要发起审批，避免在只读场景下发起不必要的审批请求
   - 不需要使用写入 API → 可不发起审批
   - 需要使用需要审批的 API → 选择发起审批
   - 其他流程同上

2. UI 调用 Connectors API → 不需要审批的 API 能够正常返回数据，需要审批的 API 则调用失败

3. CLI 调用 Connectors API → 不需要审批的 API 能够正常返回数据，需要审批的 API 则调用失败

4. 部分工具 API 可能会出现读写操作混用的情况，考虑提供按 Connector 进行审批规则配置

**分析**：

从场景上看，需要审批的 Connector 大多是写入操作，读取操作通常是可信任的。用户有可能允许读取操作。方案 B 覆盖了大多数场景。另外，即使部分工具 API 混用 HTTP 方法，用户可以选择更精细的配置，或者严格管控，使用方案 A 作为兜底。

**建议**：方案 B（HTTP 方法）为主，方案 A 作为兜底选项，方案 C 作为将来扩展的选项。

---

## 5. 审批类型

参考 Tekton CD，支持以下审批类型：

| 审批类型             | 说明                                                       |
| -------------------- | ---------------------------------------------------------- |
| **人工审批**         | 指定用户/用户组进行审批，支持延迟审批等                     |
| **时间窗口自动审批** | 某个时间段内自动通过审批，支持时区配置                     |
| **外部系统检查**（扩展） | 调用其他 Connector 的 REST API 进行检查，通过 CEL 表达式配置判断逻辑 |
| **外部系统触发**（扩展） | 提供 API 接口供外部系统调用，触发审批结果（Email、Slack、DingTalk 等） |
| **自定义脚本检查**（扩展） | 通过用户编写的脚本进行审批逻辑判断，使用轮询模式获取脚本结果 |

---

## 6. 用户体验

### 6.1 Pipeline 通过 Workspace 挂载

1. 流水线执行时，通过 Workspace 挂载需要审批的 Connector
2. 流水线执行时，根据用户配置产生审批请求，流水线 Pending，等待审批
3. 审批人收到通知，登录系统查看待审批请求信息和上下文
4. 审批人进行 Approve / Reject 操作，填写审批备注
5. 流水线发起人收到审批结果通知，流水线 Pod 挂载成功或失败，流水线继续执行或失败

### 6.2 Job 通过 Workspace 挂载

流程类似 Pipeline 场景

### 6.3 UI 调用 Connector API

1. 用户在 Pipeline Integration 配置页面选择 Connector
2. 前端调用 Connector API（GET 请求）
3. 服务端根据 Connector 审批配置判断结果：
   - 不需要审批 → 直接返回数据
   - 需要审批 → 拒绝请求，返回错误信息
4. 用户看到仓库列表、分支列表等数据

### 6.4 CLI 调用 Connector API

1. 用户主动发起审批请求
2. 审批人收到通知，进行审批
3. 用户收到审批结果通知
4. 用户使用 Connector API（在授权时间内）

---

## 7. 产品功能

### 7.1 Approvals & Checks 配置

| 功能项             | 功能描述                                                                                                     |
| ------------------ | ------------------------------------------------------------------------------------------------------------ |
| Connector 级别配置 | 在具体的 Connector 实例上配置 Approvals & Checks                                                             |
| 审批类型           | 支持多种审批类型（人工审批、时间窗口、Connector API 检查、外部系统检查、外部系统触发、自定义脚本检查等）       |
| Connector API 检查 | 调用其他 Connector 的 REST API 进行检查，通过 CEL 表达式配置判断逻辑（扩展）                                 |
| 外部系统触发       | 提供 API 接口供外部系统调用，触发审批结果（扩展）                                                            |
| 自定义脚本检查     | 支持用户自定义脚本完成检查逻辑，轮询模式（扩展）                                                             |
| HTTP 方法过滤      | 配置需要审批的 HTTP 方法（GET/POST/PUT/DELETE）                                                              |

### 7.2 Approvals & Checks 请求

| 功能项            | 功能描述                                                                              |
| ----------------- | ------------------------------------------------------------------------------------- |
| CSI 自动创建      | K8s Workload 通过 CSI 挂载需要审批的 Connector 时，自动/根据用户配置创建审批请求      |
| CLI 手动创建      | CLI 用户主动发起审批请求（第二期）                                                    |
| 请求上下文关联    | 审批请求关联 PipelineRun、TaskRun、Pod 上下文信息，便于审批人决策，控制审批复用范围   |
| 请求状态管理      | 支持 Pending/Approved/Rejected/Timeout 状态流转                                       |

### 7.3 Approvals & Checks 处理

| 功能项              | 功能描述                                                                |
| ------------------- | ----------------------------------------------------------------------- |
| 请求校验            | 用户请求 Connectors（API、Proxy）时，校验请求是否经过审批，未通过则拒绝 |
| Pipeline/Pod 阻塞   | 审批结果未确认时 Workload CSI 挂载处于 Pending 状态，审批结果确定后继续执行 |
| 审批操作            | 审批人 Approve / Reject 某次审批请求，支持填写审批备注，并可选赋予授权时间 |
| 检查操作            | 系统自动执行检查操作，直到结果确认                                      |

### 7.4 Approvals & Checks 记录

| 功能项                | 功能描述                                               |
| --------------------- | ------------------------------------------------------ |
| 单 Connector 记录查询 | 查询当前 Connector 关联的审批请求记录                  |
| 全局记录查询          | 查询所有 Connector 的审批请求记录，支持按条件筛选      |
| 根据资源 Owner 查询   | 支持查看某个 PipelineRun/TaskRun/Job/Pod 关联的审批记录 |

### 7.5 Approvals & Checks 通知

| 功能项       | 功能描述                             |
| ------------ | ------------------------------------ |
| 审批请求通知 | 审批请求创建时通知审批人             |
| 审批结果通知 | 审批完成后通知发起人                 |
| 外部通知渠道 | 支持钉钉/企微/邮件等外部通知（扩展） |

---

## 8. 实施计划

TODO

---

## 9. 局限性与风险

| 局限               | 影响                                                 | 缓解措施                                      |
| ------------------ | ---------------------------------------------------- | --------------------------------------------- |
| **审批上下文有限** | 审批人只能看到有限的上下文信息，可能影响决策         | 提供跳转链接到 PipelineRun/TaskRun 详情页     |
| **突发配置变更**   | 正在使用中的 Connector 突然开启审批，会中断现有使用  | 文档说明，建议在低峰期变更                    |

---

## 10. Open Questions

### 10.1 制品晋级场景的适配性

**问题**：我们是否能将制品晋级的策略检查放在 Connectors 上？

**Azure DevOps 的优势**：抽象了 Environment 的概念，Environment 在 Deployment Stage 中，当前上下文中必然会携带制品信息，从而可以使用 Evaluate artifact 类型的 Check。

**我们的局限**：Connector 抽象本身不含有具体的业务意图，无法根据上下文提供符合业务目标的审批检查。

**可能的解决方案**：
1. Connector 审批时，允许传入额外的展示信息，辅助用户进行审批
2. 提供完全自由的检查机制：申请者传入数据信息，自定义脚本识别意图，完成审批
